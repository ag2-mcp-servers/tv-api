# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T08:42:04+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Path, Query
from pydantic import constr

from models import (
    AssetAssetIdContributorGetResponse,
    AssetAssetIdGetResponse,
    AssetGetResponse,
    CatalogueCatalogueIdAssetAssetIdGetResponse,
    CatalogueCatalogueIdAssetGetResponse,
    CatalogueCatalogueIdGetResponse,
    CatalogueGetResponse,
    ChannelChannelIdGetResponse,
    ChannelGetResponse,
    ContributorContributorIdGetResponse,
    ContributorGetResponse,
    FeatureFeatureIdGetResponse,
    FeatureGetResponse,
    FeatureTypeGetResponse,
    PlatformGetResponse,
    PlatformPlatformIdGetResponse,
    PlatformPlatformIdRegionGetResponse,
    ScheduleGetResponse,
)

app = MCPProxy(
    description='Welcome to the API Reference Docs page for the Press Association TV API (v2).',
    title='TV API',
    version='2.0',
    servers=[
        {'url': 'https://tv.api.pressassociation.io/v2'},
        {'url': 'http://tv.api.pressassociation.io/v2'},
    ],
)


@app.get(
    '/asset',
    description=""" Return a collection of Assets. """,
    tags=['asset_tracking', 'catalogue_creating'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def list_assets(
    updated_after: Optional[constr(pattern=r'date-time')] = Query(
        '2015-05-05T00:00:00.000Z', alias='updatedAfter'
    ),
    limit: Optional[int] = 100,
    aliases: Optional[bool] = True,
):
    """
    Asset Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/asset/{assetId}',
    description=""" Return the content of the selected asset. """,
    tags=['asset_tracking', 'catalogue_creating'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_asset(
    asset_id: str = Path(..., alias='assetId'), aliases: Optional[bool] = True
):
    """
    Asset Detail
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/asset/{assetId}/contributor',
    description=""" Return the contributors of the selected asset. """,
    tags=['asset_tracking', 'contributor_overview'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_asset_contributors(
    asset_id: str = Path(..., alias='assetId'), aliases: Optional[bool] = True
):
    """
    Asset Contributors
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/catalogue',
    description=""" Return a collection of Catalogues. """,
    tags=['catalogue_creating', 'asset_tracking'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def list_catalogues():
    """
    Catalogue Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/catalogue/{catalogueId}',
    description=""" Return the content of the selected catalogue. """,
    tags=['catalogue_creating'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_catalogue(catalogue_id: str = Path(..., alias='catalogueId')):
    """
    Catalogue Detail
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/catalogue/{catalogueId}/asset',
    description=""" Return the content of the selected catalogue. """,
    tags=['catalogue_creating', 'asset_tracking'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_catalogue_asset(
    catalogue_id: str = Path(..., alias='catalogueId'),
    title: Optional[str] = None,
    start: Optional[constr(pattern=r'date-time')] = '2015-05-05T00:00:00',
    end: Optional[constr(pattern=r'date-time')] = '2015-05-06T00:00:00',
    updated_after: Optional[constr(pattern=r'date-time')] = Query(
        '2015-05-06T00:00:00', alias='updatedAfter'
    ),
    limit: Optional[float] = 500,
    aliases: Optional[bool] = True,
):
    """
    Catalogue Asset Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/catalogue/{catalogueId}/asset/{assetId}',
    description=""" Return the content of the selected catalogue asset. """,
    tags=['asset_tracking', 'catalogue_creating'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_catalogue_asset_detail(
    catalogue_id: str = Path(..., alias='catalogueId'),
    asset_id: str = Path(..., alias='assetId'),
):
    """
    Catalogue Asset Detail
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/channel',
    description=""" If you are interested in a list of channels that have had there schedule updated you can filter by the following query params.
 - scheduleStart
 - scheduleEnd
 - scheduleUpdatedSince

adding these query params will filter the channel collection to only return channels that have been updated within the given range, updatedSince stores the state of your previous call.

Example Usage: Every 10 minutes get me the channels that have updated schedules for the next 2 weeks.

/channel?platform={uuid}&scheduleStart={today}&scheduleEnd={today + 2 weeks}&updatedSince={10 minutes ago}

Also please note epg numbers are only exposed when a platform and region are passed to the query. """,
    tags=['channel_overview', 'schedule_tracking', 'platform_info'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def list_channels(
    platform_id: Optional[str] = Query(
        'd3b26caa-8c7d-5f97-9eff-40fcf1a6f8d3', alias='platformId'
    ),
    region_id: Optional[str] = Query(
        'afa4f624-da9b-54ce-b514-570345dbbdce', alias='regionId'
    ),
    aliases: Optional[bool] = True,
    date: Optional[constr(pattern=r'date')] = '2018-09-15',
    schedule_start: Optional[constr(pattern=r'date-time')] = Query(
        '2015-05-05T00:00:00', alias='scheduleStart'
    ),
    schedule_end: Optional[constr(pattern=r'date-time')] = Query(
        '2015-05-06T00:00:00', alias='scheduleEnd'
    ),
    schedule_updated_since: Optional[constr(pattern=r'date-time')] = Query(
        '2015-05-05T00:00:00', alias='scheduleUpdatedSince'
    ),
):
    """
    Channel Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/channel/{channelId}',
    description=""" Return the content of the selected channel. """,
    tags=['channel_overview'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_channel(
    channel_id: str = Path(..., alias='channelId'), aliases: Optional[bool] = True
):
    """
    Channel Detail
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contributor',
    description=""" Return a collection of Contributors. """,
    tags=['contributor_overview'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def list_contributor(
    updated_after: Optional[constr(pattern=r'date-time')] = Query(
        '2015-05-05T00:00:00.000Z', alias='updatedAfter'
    ),
    limit: Optional[int] = 100,
    aliases: Optional[bool] = True,
):
    """
    Contributor Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contributor/{contributorId}',
    description=""" Return the content of the selected contributor. """,
    tags=['contributor_overview'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_contributor(
    contributor_id: str = Path(..., alias='contributorId'),
    aliases: Optional[bool] = True,
):
    """
    Contributor Detail
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/feature',
    description=""" Return a collection of Feature. """,
    tags=['feature_overview'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def list_features(
    type: Optional[str] = 'netflix-monthly',
    date: Optional[constr(pattern=r'date')] = '2018-09-15',
    start: Optional[constr(pattern=r'date')] = '2018-09-15',
    end: Optional[constr(pattern=r'date')] = '2018-10-15',
):
    """
    Feature Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/feature-type',
    description=""" Return a collection of Feature Types. """,
    tags=['catalogue_creating', 'feature_overview'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def list_feature_types():
    """
    Feature Type Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/feature/{featureId}',
    description=""" Return the content of the selected feature. """,
    tags=['feature_overview'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_feature(feature_id: str = Path(..., alias='featureId')):
    """
    Feature Detail
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/platform',
    description=""" Return a list of available platforms. """,
    tags=['platform_info', 'asset_tracking'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def list_platforms(aliases: Optional[bool] = True):
    """
    Platform Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/platform/{platformId}',
    description=""" Return the content of the selected platform. """,
    tags=['platform_info'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_platform(platform_id: str = Path(..., alias='platformId')):
    """
    Platform Detail
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/platform/{platformId}/region',
    description=""" Return a list of regions for a platform. """,
    tags=['platform_info'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def list_platform_regions(
    platform_id: str = Path(..., alias='platformId'), aliases: Optional[bool] = True
):
    """
    Platform Region Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/schedule',
    description=""" The schedule endpoint produces a linear TV schedule for a given channel and date range.

 - The date range supplied must be no larger than 21 days.
 - If no end data is passed the API will default to start date + 24 hours. """,
    tags=['schedule_tracking', 'channel_overview'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def list_schedule(
    channel_id: str = Query(..., alias='channelId'),
    start: constr(pattern=r'date-time') = '2015-05-05T00:00:00',
    end: Optional[constr(pattern=r'date-time')] = '2015-05-06T00:00:00',
    aliases: Optional[bool] = True,
):
    """
    Schedule Collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
